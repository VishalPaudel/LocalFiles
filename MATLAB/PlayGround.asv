
S_name = ["rainy" "sunny"];
O_name = ["walking" "shopping" "cleaning"];
observed_Y = ["walking" "walking" "shopping" "walking" "cleaning"];

pi = [0.43, 0.57];

P = [0.2 0.8; 0.4 0.6];

E = [0.2 0.4 0.4; 0.3 0.25 0.45];




% Code Begins
format long;

S = (1:length(S_name));
O = (1:length(O_name));
Y = zeros(1, length(observed_Y));

K = length(S);
T = length(Y);

for i = (1: T)

    Y(1, i) = find(O_name==observed_Y(1, i));
end


viterbi_prob = [];
viterbi_path = [];

% Initialisation
for i = (1: K)
    
    viterbi_prob(i, 1) = pi(1, i) * E(i, Y(1, 1));
    viterbi_path(i, 1) = 0;
end


% Compute Viterbi probabilities and Viterbi path
for j = (2: length(Y))
    
    for i = (1: length(S))
        
        max_elem = -1;
        for alpha_iterator = (1: length(S))

            alpha = S(1, alpha_iterator);
            elem = E(i, Y(1, j)) * P(alpha, i) * viterbi_prob(alpha, j - 1);

            if elem > max_elem
                max_elem = elem;
                max_alpha = alpha;
            end
        end

        viterbi_prob(i, j) = max_elem;
        viterbi_path(i, j) = max_alpha;
    end
end

max_elem = -1;
for alpha_iterator = (1: length(S))

    alpha = S(1, alpha_iterator);
    elem = viterbi_prob(alpha, T);

    if elem > max_elem

        max_elem = elem;
        max_alpha = alpha;
    end
end

z_T = max_alpha;
X = zeros(1, length(Y));

X(1, T) = z_T;

% Back - Tracing
for j = (length(Y): -1: 2)

    max_elem = -1;
    for alpha_iterator = (1: length(S))
    
        alpha = S(1, alpha_iterator);
        elem = viterbi_prob(alpha, j);

        if elem > max_elem
    
            max_elem = elem;
            max_alpha = alpha;
        end
    end

    z_j = max_alpha;
    z_jm1 = viterbi_path(z_j, j);
    X(1, j - 1) = S(1, z_jm1);

end

% Displaying the most probable path
for i = (1: T)
    if i == 1

        fprintf('Start ')

    elseif i == T

        fprintf('End')
    else
    end

    

end
